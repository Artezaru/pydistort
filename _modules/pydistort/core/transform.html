
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pydistort.core.transform &#8212; pydistort 3.1.2 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=4e920bdf"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pydistort/core/transform';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">pydistort 3.1.2 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../installation.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../usage.html">
    Usage
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../installation.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../usage.html">
    Usage
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">pydistort.core.transform</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pydistort.core.transform</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy</span>

<div class="viewcode-block" id="TransformResult">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.TransformResult">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TransformResult</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to represent the result of a transformation.</span>

<span class="sd">    This class is used to store the results of a transformation, including the transformed points and the Jacobian matrices.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        - :class:`pydistort.core.Transform` for the base class of all transformations.</span>
<span class="sd">        - :meth:`pydistort.core.Transform.transform` for applying the transformation to points.</span>
<span class="sd">        - :meth:`pydistort.core.Transform.inverse_transform` for applying the inverse transformation to points (`output_dim` and `input_dim` are swapped).</span>

<span class="sd">    For a transformation from :math:`\mathbb{R}^{input\_dim}` to :math:`\mathbb{R}^{output\_dim}`, the input points are assumed to have shape (..., input_dim) and the output points will have shape (..., output_dim).</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>

<span class="sd">        If ``transpose`` is set to True during the transformation, the output points will have shape (output_dim, ...) instead of (..., output_dim), same for the Jacobian matrices.</span>

<span class="sd">    Some short-hand notation for the Jacobian matrices can be added to the `TransformResult` class usaing the `add_jacobian` method, which allows to add custom views of the ``dp`` Jacobian matrix with respect to the parameters of the transformation.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        result = TransformResult(transformed_points, jacobian_dx, jacobian_dp)</span>
<span class="sd">        result.add_jacobian(&quot;dk&quot;, start=0, end=2, doc=&quot;Custom Jacobian view for two first parameters related to k1 and k2&quot;)</span>

<span class="sd">        result.jacobian_dk # This will return a view of the jacobian_dp matrix with respect to the parameters k1 and k2, i.e., jacobian_dp[..., 0:2]</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    transformed_points : numpy.ndarray</span>
<span class="sd">        The transformed points after applying the transformation.</span>
<span class="sd">        Shape (..., output_dim).</span>

<span class="sd">    jacobian_dx : Optional[numpy.ndarray]</span>
<span class="sd">        The Jacobian matrix with respect to the input points.</span>
<span class="sd">        Shape (..., output_dim, input_dim).</span>

<span class="sd">    jacobian_dp : Optional[numpy.ndarray]</span>
<span class="sd">        The Jacobian matrix with respect to the parameters of the transformation.</span>
<span class="sd">        Shape (..., output_dim, Nparams).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">transformed_points</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">jacobian_dx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">jacobian_dp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_custom_jacobians</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># To avoid mutability issues, we use field with default_factory</span>

<div class="viewcode-block" id="TransformResult.add_jacobian">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.TransformResult.add_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">doc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a custom view of the `jacobian_dp` matrix to the `TransformResult` object.</span>

<span class="sd">        This method allows to add custom views of the `jacobian_dp` matrix with respect to the parameters of the transformation.</span>
<span class="sd">        The custom Jacobian can be accessed using the `name` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the custom Jacobian view.</span>
<span class="sd">        </span>
<span class="sd">        start : int</span>
<span class="sd">            The starting index of the parameters to include in the custom Jacobian view.</span>
<span class="sd">        </span>
<span class="sd">        end : int</span>
<span class="sd">            The ending index of the parameters to include in the custom Jacobian view.</span>
<span class="sd">        </span>
<span class="sd">        doc : Optional[str], optional</span>
<span class="sd">            A documentation string for the custom Jacobian view. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;name must be a string, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start must be an integer, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;end must be an integer, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">doc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;doc must be a string, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacobian_dp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span> <span class="ow">or</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacobian_dp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid range for custom Jacobian view: start=</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">, end=</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2">, Nparams=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">jacobian_dp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_custom_jacobians</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">doc</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;jacobian_&quot;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;jacobian_&quot;</span><span class="p">):]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_custom_jacobians</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacobian_dp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_custom_jacobians</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacobian_dp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;TransformResult&#39; object has no attribute &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="TransformResult.describe_jacobians">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.TransformResult.describe_jacobians">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">describe_jacobians</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the descriptions of the custom Jacobian views.</span>

<span class="sd">        This method prints the names and documentation strings of the custom Jacobian views added to the `TransformResult` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tranformed_points: The transformed points after applying the transformation with shape (..., output_dim)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;jacobian_dx: The Jacobian matrix with respect to the input points with shape (..., output_dim, input_dim) [or None if not computed]&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;jacobian_dp: The Jacobian matrix with respect to the parameters of the transformation with shape (..., output_dim, Nparams) [or None if not computed]&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">doc</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_custom_jacobians</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;jacobian_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">doc</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">doc</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="kc">None</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;No description provided&#39;</span><span class="si">}</span><span class="s2"> with shape (..., output_dim, </span><span class="si">{</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="si">}</span><span class="s2">) [or None if not computed], view of jacobian_dp[..., </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span></div>
</div>















<div class="viewcode-block" id="Transform">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.Transform">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Transform</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform is the base class to manage transformations from :math:`\mathbb{R}^{input\_dim}` to :math:`\mathbb{R}^{output\_dim}`.</span>

<span class="sd">    .. math::</span>

<span class="sd">        X_O = T(X_I, \lambda_1, \lambda_2, \ldots, \lambda_N)</span>

<span class="sd">    where :math:`X_O` are the output points, :math:`X_I` are the input points, and :math:`\{\lambda_1, \lambda_2, \ldots, \lambda_N\}` are the parameters of the transformation.</span>

<span class="sd">    In this package, the transformations wiil be used to project 3D-world points onto a 2D-image plane in the stenopic camera model.</span>

<span class="sd">    The process to correspond a 3D-world point to a 2D-image point in the stenopic camera model is as follows:</span>

<span class="sd">    1. The ``world_3dpoints`` (:math:`X_W`) are expressed in the camera coordinate system using the rotation and translation matrices to obtain the ``camera_3dpoints`` (:math:`X_C`).</span>
<span class="sd">    2. The ``camera_3dpoints`` (:math:`X_C`) are normalized by dividing by the third coordinate to obtain the ``normalized_points`` (:math:`x_N`).</span>
<span class="sd">    3. The ``normalized_points`` (:math:`x_N`) are distorted by the distortion model using the coefficients :math:`\{\lambda_1, \lambda_2, \lambda_3, \ldots\}` to obtain the ``distorted_points`` (:math:`x_D`).</span>
<span class="sd">    4. The ``distorted_points`` (:math:`x_D`) are projected onto the image plane using the intrinsic matrix K to obtain the ``image_points`` (:math:`x_I`).</span>

<span class="sd">    This tranformation can be decomposed into 3 main steps:</span>

<span class="sd">    1. **Extrinsic**: Transform the ``world_3dpoints`` to ``normalized_points`` using the extrinsic parameters (rotation and translation).</span>
<span class="sd">    2. **Distortion**: Transform the ``normalized_points`` to ``distorted_points`` using the distortion model.</span>
<span class="sd">    3. **Intrinsic**: Transform the ``distorted_points`` to ``image_points`` using the intrinsic matrix K.</span>

<span class="sd">    This class provides the base for all transformations in the stenopic camera model. It defines the interface for extrinsic, distortion, and intrinsic transformations.</span>

<span class="sd">    Each sub-classes must implement the following methods and properties:</span>

<span class="sd">    - ``input_dim``: (property) The dimension of the input points (should be 2 for 2D points).</span>
<span class="sd">    - ``output_dim``: (property) The dimension of the output points (should be 2 for 2D points).</span>
<span class="sd">    - ``parameters`` (property and setter) The parameters of the transformation in a 1D numpy array of shape (Nparams,).</span>
<span class="sd">    - ``is_set``: (method) Check if the transformation is set (i.e., if the parameters are initialized).</span>
<span class="sd">    - ``_transform``: (method) Apply the transformation to the given points.</span>
<span class="sd">    - ``_inverse_transform``: (method) Apply the inverse transformation to the given points.</span>

<span class="sd">    The following properties are not required but can be implemented to provide additional information about the transformation:</span>

<span class="sd">    - ``result_class``: (property) The class used for the result of the transformation (sub-class of ``TransformResult``). Default is :class:`pydistort.core.TransformResult`.</span>
<span class="sd">    - ``inverse_result_class``: (property) The class used for the result of the inverse transformation (sub-class of ``TransformResult``). Default is :class:`pydistort.core.TransformResult`.</span>
<span class="sd">    - ``_jacobian_short_hand``: (property) A dictionary of short-hand notation for the Jacobian matrices, which can be used to add custom views of the ``jacobian_dp`` matrix with respect to the parameters of the transformation.</span>

<span class="sd">    More details on the transformation methods are provided in the `transform` and `inverse_transform` methods. </span>

<span class="sd">    .. seealso::</span>

<span class="sd">        - :meth:`pydistort.core.Transform.transform` for applying the transformation to points.</span>
<span class="sd">        - :meth:`pydistort.core.Transform.inverse_transform` for applying the inverse transformation to points.</span>
<span class="sd">        - :class:`pydistort.core.TransformResult` for the result of the transformation.</span>

<span class="sd">    .. note::</span>

<span class="sd">        ``...`` in the shape of the attributes indicates that the shape can have any number of leading dimensions, which is useful for batch processing of points.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># =============================================</span>
    <span class="c1"># Properties for ABC Transform Class</span>
    <span class="c1"># =============================================</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">result_class</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property to return the class used for the result of the transformation.</span>
<span class="sd">        </span>
<span class="sd">        The default is `TransformResult`, but subclasses can override this to return a different class.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            The class used for the result of the transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TransformResult</span>
    

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inverse_result_class</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property to return the class used for the result of the inverse transformation.</span>
<span class="sd">        </span>
<span class="sd">        The default is `TransformResult`, but subclasses can override this to return a different class.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            The class used for the result of the inverse transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TransformResult</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_jacobian_short_hand</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property to return a dictionary of short-hand notation for the Jacobian matrices.</span>
<span class="sd">        </span>
<span class="sd">        This dictionary can be used to add custom views of the `jacobian_dp` matrix with respect to the parameters of the transformation.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            {</span>
<span class="sd">                &quot;dk&quot;: (0, 2, &quot;Custom Jacobian view for two first parameters related to k1 and k2&quot;),</span>
<span class="sd">                &quot;dother&quot;: (2, 4, &quot;Custom Jacobian view for other parameters related to k3 and k4&quot;),</span>
<span class="sd">            }</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict[str, Tuple[int, int, Optional[str]]]</span>
<span class="sd">            A dictionary where keys are names of the custom Jacobian views and values are tuples containing:</span>

<span class="sd">            - start index (int): The starting index of the parameters to include in the custom Jacobian view.</span>
<span class="sd">            - end index (int): The ending index of the parameters to include in the custom Jacobian view.</span>
<span class="sd">            - doc (Optional[str]): A documentation string for the custom Jacobian view.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span> 
    
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Nparams</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property to return the number of parameters of the transformation.</span>
<span class="sd">        </span>
<span class="sd">        The number of parameters must be a non-negative integer representing the number of parameters of the transformation.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of parameters of the transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">size</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of the Transform class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A string representation of the transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="si">}</span><span class="s2"> parameters: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;not set&#39;</span><span class="si">}</span><span class="s2">&quot;</span>


    <span class="c1"># =============================================</span>
    <span class="c1"># To be implemented by subclasses</span>
    <span class="c1"># =============================================</span>
    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property to return the input dimension of the transformation.</span>
<span class="sd">        </span>
<span class="sd">        The input dimension must be a positive integer representing the number of dimensions of the input points.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of dimensions of the input points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property to return the output dimension of the transformation.</span>
<span class="sd">        </span>
<span class="sd">        The output dimension must be a positive integer representing the number of dimensions of the output points.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of dimensions of the output points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property to return the parameters of the transformation.</span>
<span class="sd">        </span>
<span class="sd">        The parameters must be a 1-D numpy array of shape (Nparams,) where Nparams is the number of parameters of the transformation.</span>

<span class="sd">        If the transformation does not have parameters or they are not set, this property should return None.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[numpy.ndarray]</span>
<span class="sd">            The parameters of the transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


<div class="viewcode-block" id="Transform.is_set">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.Transform.is_set">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to check if the transformation parameters are set.</span>
<span class="sd">        </span>
<span class="sd">        This method should return True if the transformation parameters are initialized, otherwise False.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the transformation parameters are set, otherwise False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>



<div class="viewcode-block" id="Transform._transform">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.Transform._transform">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transformation to the given points.</span>

<span class="sd">        This method must be implemented by subclasses to apply the transformation to the input points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : numpy.ndarray</span>
<span class="sd">            The input points to be transformed. Shape (Npoints, input_dim).</span>

<span class="sd">        dx : bool, optional</span>
<span class="sd">            If True, compute the Jacobian of the transformed points with respect to the input points. Default is False.</span>

<span class="sd">        dp : bool, optional</span>
<span class="sd">            If True, compute the Jacobian of the transformed points with respect to the parameters of the transformation. Default is False.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments for the transformation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[numpy.ndarray, Optional[numpy.ndarray], Optional[numpy.ndarray]]</span>
<span class="sd">            A tuple containing:</span>

<span class="sd">            - `transformed_points`: The transformed points of shape (Npoints, output_dim).</span>
<span class="sd">            - `jacobian_dx`: The Jacobian matrix with respect to the input points of shape (Npoints, output_dim, input_dim) if `dx` is True, otherwise None.</span>
<span class="sd">            - `jacobian_dp`: The Jacobian matrix with respect to the parameters of the transformation of shape (Npoints, output_dim, Nparams) if `dp` is True, otherwise None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement the _transform method.&quot;</span><span class="p">)</span></div>

    

<div class="viewcode-block" id="Transform._inverse_transform">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.Transform._inverse_transform">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_inverse_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the inverse transformation to the given points.</span>

<span class="sd">        This method must be implemented by subclasses to apply the inverse transformation to the input points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : numpy.ndarray</span>
<span class="sd">            The input points to be transformed. Shape (Npoints, output_dim).</span>

<span class="sd">        dx : bool, optional</span>
<span class="sd">            If True, compute the Jacobian of the transformed points with respect to the input points. Default is False.</span>

<span class="sd">        dp : bool, optional</span>
<span class="sd">            If True, compute the Jacobian of the transformed points with respect to the parameters of the transformation. Default is False.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments for the transformation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[numpy.ndarray, Optional[numpy.ndarray], Optional[numpy.ndarray]]</span>
<span class="sd">            A tuple containing:</span>

<span class="sd">            - `transformed_points`: The transformed points of shape (Npoints, input_dim).</span>
<span class="sd">            - `jacobian_dx`: The Jacobian matrix with respect to the input points of shape (Npoints, input_dim, output_dim) if `dx` is True, otherwise None.</span>
<span class="sd">            - `jacobian_dp`: The Jacobian matrix with respect to the parameters of the transformation of shape (Npoints, input_dim, Nparams) if `dp` is True, otherwise None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement the _inverse_transform method.&quot;</span><span class="p">)</span></div>


    
    <span class="c1"># =============================================</span>
    <span class="c1"># Transformation Methods</span>
    <span class="c1"># =============================================</span>

<div class="viewcode-block" id="Transform.return_result">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.Transform.return_result">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">return_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform_result</span><span class="p">:</span> <span class="n">TransformResult</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TransformResult</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of the transformation as a ``TransformResult`` object.</span>

<span class="sd">        This method is used to return the result of the transformation, including the transformed points and the Jacobian matrices if requested.</span>

<span class="sd">        This medthos also add the custom Jacobian views to the `TransformResult` object using the `add_jacobian` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transform_result : TransformResult</span>
<span class="sd">            The result of the transformation containing the transformed points and the Jacobian matrices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TransformResult</span>
<span class="sd">            The result of the transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform_result</span><span class="p">,</span> <span class="n">TransformResult</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transform_result must be an instance of TransformResult, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">transform_result</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Add custom Jacobian views to the TransformResult object</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">doc</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_short_hand</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">transform_result</span><span class="o">.</span><span class="n">add_jacobian</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">transform_result</span></div>



<div class="viewcode-block" id="Transform.transform">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.Transform.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">transpose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_skip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The given points ``points`` are assumed to be with shape (..., input_dim) or (input_dim, ...), depending on the value of ``transpose``.</span>

<span class="sd">        The output ``transformed_points`` will have shape (..., output_dim) if ``transpose`` is False, or (output_dim, ...) if ``transpose`` is True.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The points are converting to float64 before applying the transformation.</span>

<span class="sd">        The method also computes 2 Jacobian matrices if requested:</span>

<span class="sd">        - ``dx``: Jacobian of the transformed points with respect to the input points.</span>
<span class="sd">        - ``dp``: Jacobian of the transformed points with respect to the parameters of the transformation.</span>

<span class="sd">        The jacobian matrice with respect to the input points is a (..., output_dim, input_dim) matrix where:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            jacobian_dx[..., 0, 0]  # ∂x_o/∂x_i -&gt; Jacobian of the coordinates x_o with respect to the coordinates x_i.</span>
<span class="sd">            jacobian_dx[..., 0, 1]  # ∂x_o/∂y_i</span>
<span class="sd">            ...</span>
<span class="sd">            </span>
<span class="sd">            jacobian_dx[..., 1, 0]  # ∂y_o/∂x_i -&gt; Jacobian of the coordinates y_o with respect to the coordinates x_i.</span>
<span class="sd">            jacobian_dx[..., 1, 1]  # ∂y_o/∂y_i</span>
<span class="sd">            ...</span>

<span class="sd">        The Jacobian matrice with respect to the parameters is a (..., output_dim, Nparams) matrix where:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            jacobian_dp[..., 0, 0]  # ∂x_o/∂λ_1 -&gt; Jacobian of the coordinates x_o with respect to the first parameter λ_1.</span>
<span class="sd">            jacobian_dp[..., 0, 1]  # ∂x_o/∂λ_2</span>
<span class="sd">            ...</span>

<span class="sd">            jacobian_dp[..., 1, 0]  # ∂y_o/∂λ_1 -&gt; Jacobian of the coordinates y_o with respect to the first parameter λ_1.</span>
<span class="sd">            jacobian_dp[..., 1, 1]  # ∂y_o/∂λ_2</span>
<span class="sd">            ...</span>

<span class="sd">        The Jacobian matrices are computed only if ``dx`` or ``dp`` are set to True, respectively.</span>

<span class="sd">        The output will be a `TransformResult` object containing the transformed points and the Jacobian matrices if requested.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The _skip parameter is used to skip the checks for the transformation parameters and assume the points are given in the (Npoints, input_dim) float64 format.</span>
<span class="sd">            Please use this parameter with caution, as it may lead to unexpected results if the transformation parameters are not set correctly.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : numpy.ndarray</span>
<span class="sd">            The input points to be transformed. Shape (..., input_dim) (or (input_dim, ...) if `transpose` is True).</span>

<span class="sd">        transpose : bool, optional</span>
<span class="sd">            If True, the input points are transposed to shape (input_dim, ...). Default is False.</span>

<span class="sd">        dx : bool, optional</span>
<span class="sd">            If True, compute the Jacobian of the transformed points with respect to the input points. Default is False.</span>

<span class="sd">        dp : bool, optional</span>
<span class="sd">            If True, compute the Jacobian of the transformed points with respect to the parameters of the transformation. Default is False.</span>

<span class="sd">        _skip : bool, optional</span>
<span class="sd">            If True, skip the checks for the transformation parameters and assume the points are given in the (Npoints, input_dim) float64 format.</span>
<span class="sd">            `transpose` is ignored if this parameter is set to True.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments for the transformation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TransformResult</span>
<span class="sd">            An object containing the transformed points and the Jacobian matrices if requested.</span>

<span class="sd">            </span>
<span class="sd">        Developer Notes</span>
<span class="sd">        ----------------</span>
<span class="sd">        The subclasses must implement the `_transform` method to apply the transformation to the input points.</span>
<span class="sd">        </span>
<span class="sd">        The `_transform` method should:</span>

<span class="sd">        - take the input points as a numpy array of shape (Npoints, input_dim)</span>
<span class="sd">        - return 3 numpy arrays:</span>

<span class="sd">            - `transformed_points`: The transformed points of shape (Npoints, output_dim).</span>
<span class="sd">            - `jacobian_dx`: The Jacobian matrix with respect to the input points of shape (Npoints, output_dim, input_dim) if `dx` is True, otherwise None.</span>
<span class="sd">            - `jacobian_dp`: The Jacobian matrix with respect to the parameters of the transformation of shape (Npoints, output_dim, Nparams) if `dp` is True, otherwise None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_skip</span><span class="p">:</span>
            <span class="c1"># Check the boolean flags</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dx must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dp must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transpose</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transpose must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">transpose</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Check if the transformation is set</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transformation parameters are not set. Please set the parameters before transforming points.&quot;</span><span class="p">)</span>
        
            <span class="c1"># Convert input points to float64</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># Check the shape of the input points</span>
            <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input points must have at least 2 dimensions, got </span><span class="si">{</span><span class="n">points</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>

            <span class="c1"># Transpose the input points if requested</span>
            <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (input_dim, ...) -&gt; (..., input_dim)</span>

            <span class="c1"># Save the shape of the input points</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># (..., input_dim)</span>

            <span class="c1"># Check the last dimension of the input points</span>
            <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input points must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="si">}</span><span class="s2"> dimensions, got </span><span class="si">{</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>

            <span class="c1"># Flatten the input points to 2D for processing</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">)</span> <span class="c1"># (..., input_dim) -&gt; (Npoints, input_dim)</span>

        <span class="c1"># Apply the transformation</span>
        <span class="n">transformed_points</span><span class="p">,</span> <span class="n">jacobian_dx</span><span class="p">,</span> <span class="n">jacobian_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="n">dp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># (Npoints, output_dim), (Npoints, output_dim, input_dim), (Npoints, output_dim, Nparams)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_skip</span><span class="p">:</span>
            <span class="c1"># Reshape the transformed points to the original shape</span>
            <span class="n">transformed_points</span> <span class="o">=</span> <span class="n">transformed_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">)</span>  <span class="c1"># (Npoints, output_dim) -&gt; (..., output_dim)</span>
            <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="n">jacobian_dx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">)</span> <span class="k">if</span> <span class="n">jacobian_dx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>  <span class="c1"># (Npoints, output_dim, input_dim) -&gt; (..., output_dim, input_dim)</span>
            <span class="n">jacobian_dp</span> <span class="o">=</span> <span class="n">jacobian_dp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">)</span> <span class="k">if</span> <span class="n">jacobian_dp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="c1"># (Npoints, output_dim, Nparams) -&gt; (..., output_dim, Nparams)</span>

            <span class="c1"># Transpose the transformed points if requested</span>
            <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
                <span class="n">transformed_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">transformed_points</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># (..., output_dim) -&gt; (output_dim, ...)</span>
                <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">jacobian_dx</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">jacobian_dx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="c1"># (..., output_dim, input_dim) -&gt; (output_dim, ..., input_dim)</span>
                <span class="n">jacobian_dp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">jacobian_dp</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">jacobian_dp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="c1"># (..., output_dim, Nparams) -&gt; (output_dim, ..., Nparams)</span>

        <span class="c1"># Return the result as a TransformResult object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result_class</span><span class="p">(</span>
            <span class="n">transformed_points</span><span class="o">=</span><span class="n">transformed_points</span><span class="p">,</span>
            <span class="n">jacobian_dx</span><span class="o">=</span><span class="n">jacobian_dx</span><span class="p">,</span>
            <span class="n">jacobian_dp</span><span class="o">=</span><span class="n">jacobian_dp</span>
        <span class="p">))</span></div>

    

<div class="viewcode-block" id="Transform.inverse_transform">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.Transform.inverse_transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">inverse_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">transpose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_skip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The given points ``points`` are assumed to be with shape (..., output_dim) or (output_dim, ...), depending on the value of ``transpose``.</span>

<span class="sd">        The output ``transformed_points`` will have shape (..., input_dim) if ``transpose`` is False, or (input_dim, ...) if ``transpose`` is True.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The points are converting to float64 before applying the inverse transformation.</span>

<span class="sd">        The method also computes 2 Jacobian matrices if requested:</span>

<span class="sd">        - ``dx``: Jacobian of the transformed points with respect to the input points.</span>
<span class="sd">        - ``dp``: Jacobian of the transformed points with respect to the parameters of the transformation.</span>

<span class="sd">        The jacobian matrice with respect to the input points is a (..., input_dim, output_dim) matrix where:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            jacobian_dx[..., 0, 0]  # ∂x_i/∂x_o -&gt; Jacobian of the coordinates x_i with respect to the coordinates x_o.</span>
<span class="sd">            jacobian_dx[..., 0, 1]  # ∂x_i/∂y_o</span>
<span class="sd">            ...</span>
<span class="sd">            </span>
<span class="sd">            jacobian_dx[..., 1, 0]  # ∂y_i/∂x_o -&gt; Jacobian of the coordinates y_i with respect to the coordinates x_o.</span>
<span class="sd">            jacobian_dx[..., 1, 1]  # ∂y_i/∂y_o</span>
<span class="sd">            ...</span>

<span class="sd">        The Jacobian matrice with respect to the parameters is a (..., input_dim, Nparams) matrix where:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            jacobian_dp[..., 0, 0]  # ∂x_i/∂λ_1 -&gt; Jacobian of the coordinates x_i with respect to the first parameter λ_1.</span>
<span class="sd">            jacobian_dp[..., 0, 1]  # ∂x_i/∂λ_2</span>
<span class="sd">            ...</span>

<span class="sd">            jacobian_dp[..., 1, 0]  # ∂y_i/∂λ_1 -&gt; Jacobian of the coordinates y_i with respect to the first parameter λ_1.</span>
<span class="sd">            jacobian_dp[..., 1, 1]  # ∂y_i/∂λ_2</span>
<span class="sd">            ...</span>

<span class="sd">        The Jacobian matrices are computed only if ``dx`` or ``dp`` are set to True, respectively.</span>

<span class="sd">        The output will be a `TransformResult` object containing the transformed points and the Jacobian matrices if requested.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The _skip parameter is used to skip the checks for the transformation parameters and assume the points are given in the (Npoints, output_dim) float64 format.</span>
<span class="sd">            Please use this parameter with caution, as it may lead to unexpected results if the transformation parameters are not set correctly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : numpy.ndarray</span>
<span class="sd">            The input points to be transformed. Shape (..., output_dim) (or (output_dim, ...) if `transpose` is True).</span>

<span class="sd">        transpose : bool, optional</span>
<span class="sd">            If True, the input points are transposed to shape (output_dim, ...). Default is False.</span>

<span class="sd">        dx : bool, optional</span>
<span class="sd">            If True, compute the Jacobian of the transformed points with respect to the input points. Default is False.</span>

<span class="sd">        dp : bool, optional</span>
<span class="sd">            If True, compute the Jacobian of the transformed points with respect to the parameters of the transformation. Default is False.</span>

<span class="sd">        _skip : bool, optional</span>
<span class="sd">            If True, skip the checks for the transformation parameters and assume the points are given in the (Npoints, output_dim) float64 format.</span>
<span class="sd">            `transpose` is ignored if this parameter is set to True.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments for the transformation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TransformResult</span>
<span class="sd">            An object containing the transformed points and the Jacobian matrices if requested.</span>

<span class="sd">            </span>
<span class="sd">        Developer Notes</span>
<span class="sd">        ----------------</span>
<span class="sd">        The subclasses must implement the `_inverse_transform` method to apply the inverse transformation to the input points.</span>

<span class="sd">        The `_inverse_transform` method should:</span>

<span class="sd">        - take the input points as a numpy array of shape (Npoints, output_dim)</span>
<span class="sd">        - return 3 numpy arrays:</span>

<span class="sd">            - `transformed_points`: The transformed points of shape (Npoints, input_dim).</span>
<span class="sd">            - `jacobian_dx`: The Jacobian matrix with respect to the input points of shape (Npoints, input_dim, output_dim) if `dx` is True, otherwise None.</span>
<span class="sd">            - `jacobian_dp`: The Jacobian matrix with respect to the parameters of the transformation of shape (Npoints, input_dim, Nparams) if `dp` is True, otherwise None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_skip</span><span class="p">:</span>
            <span class="c1"># Check the boolean flags</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dx must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dp must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transpose</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transpose must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">transpose</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Check if the transformation is set</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transformation parameters are not set. Please set the parameters before transforming points.&quot;</span><span class="p">)</span>
            
            <span class="c1"># Convert input points to float64</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># Check the shape of the input points</span>
            <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input points must have at least 2 dimensions, got </span><span class="si">{</span><span class="n">points</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>
            
            <span class="c1"># Transpose the input points if requested</span>
            <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># (output_dim, ...) -&gt; (..., output_dim)</span>
            
            <span class="c1"># Save the shape of the input points</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># (..., output_dim)</span>

            <span class="c1"># Check the last dimension of the input points</span>
            <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input points must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="si">}</span><span class="s2"> dimensions, got </span><span class="si">{</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>
            
            <span class="c1"># Flatten the input points to 2D for processing</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">)</span> <span class="c1"># (..., output_dim)</span>

        <span class="c1"># Apply the inverse transformation</span>
        <span class="n">transformed_points</span><span class="p">,</span> <span class="n">jacobian_dx</span><span class="p">,</span> <span class="n">jacobian_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse_transform</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="n">dp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># (Npoints, input_dim), (Npoints, input_dim, output_dim), (Npoints, input_dim, Nparams)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_skip</span><span class="p">:</span>
            <span class="c1"># Reshape the transformed points to the original shape</span>
            <span class="n">transformed_points</span> <span class="o">=</span> <span class="n">transformed_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">)</span>  <span class="c1"># (Npoints, input_dim) -&gt; (..., input_dim)</span>
            <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="n">jacobian_dx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">)</span> <span class="k">if</span> <span class="n">jacobian_dx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>  <span class="c1"># (..., input_dim, output_dim)</span>
            <span class="n">jacobian_dp</span> <span class="o">=</span> <span class="n">jacobian_dp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">)</span> <span class="k">if</span> <span class="n">jacobian_dp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="c1"># (..., input_dim, Nparams)</span>

            <span class="c1"># Transpose the transformed points if requested</span>
            <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
                <span class="n">transformed_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">transformed_points</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># (..., input_dim) -&gt; (input_dim, ...)</span>
                <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">jacobian_dx</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">jacobian_dx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="c1"># (..., input_dim, output_dim) -&gt; (input_dim, ..., output_dim)</span>
                <span class="n">jacobian_dp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">jacobian_dp</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">jacobian_dp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="c1"># (..., input_dim, Nparams) -&gt; (input_dim, ..., Nparams)</span>

        <span class="c1"># Return the result as a InverseTransformResult object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inverse_result_class</span><span class="p">(</span>
            <span class="n">transformed_points</span><span class="o">=</span><span class="n">transformed_points</span><span class="p">,</span>
            <span class="n">jacobian_dx</span><span class="o">=</span><span class="n">jacobian_dx</span><span class="p">,</span>
            <span class="n">jacobian_dp</span><span class="o">=</span><span class="n">jacobian_dp</span>
        <span class="p">))</span></div>

    
    
    <span class="c1"># =============================================</span>
    <span class="c1"># Optimization Methods</span>
    <span class="c1"># =============================================</span>

<div class="viewcode-block" id="Transform.optimize_parameters">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.Transform.optimize_parameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize_parameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">input_points</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">output_points</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">guess</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">transpose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cond_cutoff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">,</span>
        <span class="n">reg_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">precond_jacobi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_skip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_verbose_eigen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the parameters of the transformation using the given input and output points.</span>

<span class="sd">        Estimate the optimized parameters of the transformation such that the transformed input points match the output points.</span>

<span class="sd">        Lets consider a set of input points :math:`X_I` with shape (..., input_dim) and a set of output points :math:`X_O` with shape (..., output_dim).</span>
<span class="sd">        We search :math:`\lambda = \lambda_0 + \delta \lambda` such that:</span>

<span class="sd">        .. math::</span>

<span class="sd">            X_O = \text{Transform}(X_I, \lambda) = T(X_I, \lambda_0 + \delta \lambda)</span>

<span class="sd">        .. note::</span>

<span class="sd">            The current parameters of the transformation are not directly modified.</span>
<span class="sd">        </span>
<span class="sd">        We have:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla_{\lambda} T (X_I, \lambda_0) \delta \lambda = X_O - T(X_I, \lambda_0)</span>

<span class="sd">        The corrections are computed using the following equations:</span>

<span class="sd">        .. math::</span>

<span class="sd">            J^{T} J \delta \lambda = J^{T} R</span>

<span class="sd">        Where :math:`J = \nabla_{\lambda} T (X_I, \lambda_0)` is the Jacobian matrix of the transformation with respect to the parameters, and :math:`R = X_O - T(X_I, \lambda_0)` is the residual vector.</span>

<span class="sd">        :math:`\lambda_0` is the initial guess for the parameters, if None, the current parameters of the transformation are used.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This method can be used to optimize the parameters of any transformation that implements the `_transform` method.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The ``_skip`` parameter is used to skip the checks for the transformation parameters and assume the input and output points are given in the (Npoints, input_dim) and (Npoints, output_dim) float64 format, respectively.</span>
<span class="sd">            Please use this parameter with caution, as it may lead to unexpected results if the transformation parameters are not set correctly.</span>

<span class="sd">        For conditioning, the following steps are applied:</span>

<span class="sd">        - First, a regularization term is added to the Jacobian matrix to improve stability: :math:`J^{T} J + \text{regfactor} I`.</span>
<span class="sd">        - Second, a preconditioner is applied to the Jacobian matrix to improve the conditioning of the problem.</span>
<span class="sd">        </span>
<span class="sd">        The `cond_cutoff` parameter is used to detect ill-conditioned problems. If the condition number of the Jacobian matrix is greater than this value, a warning is raised and the optimization returns NaN array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_points : numpy.ndarray</span>
<span class="sd">            The input points to be transformed. Shape (..., input_dim) (or (input_dim, ...) if `transpose` is True).</span>
<span class="sd">        </span>
<span class="sd">        output_points : numpy.ndarray</span>
<span class="sd">            The output points to be matched. Shape (..., output_dim) (or (output_dim, ...) if `transpose` is True).</span>

<span class="sd">        guess : Optional[numpy.ndarray], optional</span>
<span class="sd">            The initial guess for the parameters of the transformation with shape (Nparams,). If None, the current parameters of the transformation are used. Default is None.</span>

<span class="sd">        transpose : bool, optional</span>
<span class="sd">            If True, the input and output points are transposed to shape (input_dim, ...) and (output_dim, ...), respectively. Default is False.</span>

<span class="sd">        max_iter : int, optional</span>
<span class="sd">            The maximum number of iterations for the optimization. Default is 10.</span>

<span class="sd">        eps : float, optional</span>
<span class="sd">            The convergence threshold for the optimization. Default is 1e-8.</span>

<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If True, print the optimization progress and diagnostics. Default is False.</span>

<span class="sd">        cond_cutoff : float, optional</span>
<span class="sd">            The cutoff value for the condition number of the Jacobian matrix. If the condition number is greater than this value, the optimization will be considered unstable and will raise a warning and return NaN array. This is used to detect ill-conditioned problems. Default is 1e5.</span>

<span class="sd">        reg_factor : float, optional</span>
<span class="sd">            The regularization factor for the optimization. If greater than 0, it adds a tikhonov regularization term to the optimization problem to improve stability :math:`J^{T} J + \text{regfactor} I`. Default is 0.0.</span>

<span class="sd">        precond_jacobi : bool, optional</span>
<span class="sd">            If True, apply a preconditioner to the Jacobian matrix to improve the conditioning of the problem. This is done by applying the Jacobi preconditioner to the Jacobian matrix before solving the optimization problem. Default is False.</span>

<span class="sd">        _skip : bool, optional</span>
<span class="sd">            If True, skip the checks for the transformation parameters and assume the input and output points are given in the (Npoints, input_dim) and (Npoints, output_dim) float64 format, respectively.</span>
<span class="sd">            The guess must be given in the (Nparams,) float64 format.</span>
<span class="sd">            `transpose` is ignored if this parameter is set to True.</span>

<span class="sd">        _verbose_eigen : bool, optional</span>
<span class="sd">            If True, display the eigenvalues of the Jacobian matrix during the optimization process. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The optimized parameters of the transformation with shape (Nparams,).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the input and output points do not have the same number of points, or if the input and output dimensions do not match the transformation&#39;s input and output dimensions.</span>

<span class="sd">        TypeError</span>
<span class="sd">            If the input and output points are not numpy arrays, or if the guess is not a numpy array.</span>

<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_skip</span><span class="p">:</span>
            <span class="c1"># Check the boolean flags</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transpose</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transpose must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">transpose</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">max_iter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_iter must be an integer greater than 0, got </span><span class="si">{</span><span class="n">max_iter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="n">eps</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;eps must be a positive float, got </span><span class="si">{</span><span class="n">eps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;verbose must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond_cutoff</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="n">cond_cutoff</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cond_cutoff must be a positive float, got </span><span class="si">{</span><span class="n">cond_cutoff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reg_factor</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="n">reg_factor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;reg_factor must be a non-negative float, got </span><span class="si">{</span><span class="n">reg_factor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precond_jacobi</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;precond_jacobi must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">precond_jacobi</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Check if the transformation is set</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transformation parameters are not set. Please set the parameters before optimizing.&quot;</span><span class="p">)</span>

            <span class="c1"># Convert input and output points to float64</span>
            <span class="n">input_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">input_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">output_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">output_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># Check the shape of the input and output points</span>
            <span class="k">if</span> <span class="n">input_points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">output_points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input and output points must have at least 2 dimensions, got </span><span class="si">{</span><span class="n">input_points</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">output_points</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions respectively.&quot;</span><span class="p">)</span>
            
            <span class="c1"># Transpose the input and output points if requested</span>
            <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
                <span class="n">input_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">input_points</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># (input_dim, ...) -&gt; (..., input_dim)</span>
                <span class="n">output_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">output_points</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># (output_dim, ...) -&gt; (..., output_dim)</span>

            <span class="c1"># Flatten the input and output points to 2D for processing</span>
            <span class="n">input_points</span> <span class="o">=</span> <span class="n">input_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">)</span>  <span class="c1"># (..., input_dim) -&gt; (Npoints, input_dim)</span>
            <span class="n">output_points</span> <span class="o">=</span> <span class="n">output_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">)</span>  <span class="c1"># (..., output_dim) -&gt; (Npoints, output_dim)</span>

            <span class="c1"># Check the number of points</span>
            <span class="k">if</span> <span class="n">input_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input and output points must have the same number of points, got </span><span class="si">{</span><span class="n">input_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> points respectively.&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">input_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input and output points must have at least one point.&quot;</span><span class="p">)</span>
            
            <span class="c1"># Check the last dimension of the input and output points</span>
            <span class="k">if</span> <span class="n">input_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input points must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="si">}</span><span class="s2"> dimensions, got </span><span class="si">{</span><span class="n">input_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output points must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="si">}</span><span class="s2"> dimensions, got </span><span class="si">{</span><span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>
            
            <span class="c1"># Check the guess</span>
            <span class="k">if</span> <span class="n">guess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">guess</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Guess must be a 1D array, got </span><span class="si">{</span><span class="n">guess</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">guess</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Guess must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="si">}</span><span class="s2"> parameters, got </span><span class="si">{</span><span class="n">guess</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> parameters.&quot;</span><span class="p">)</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use the current parameters as the guess</span>
                <span class="n">guess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        
        <span class="c1"># Return empty arrays if Nparams is 0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Create a perfect copy of the current class to avoid modifying the original one</span>
        <span class="n">object_class</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Npoints</span> <span class="o">=</span> <span class="n">input_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Number of points in computation</span>

        <span class="c1"># Set the parameters of the object class to the guess</span>
        <span class="n">object_class</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">guess</span>
        <span class="n">delta_itk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">object_class</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Run the iterative algorithm</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>

            <span class="c1">#============================================</span>
            <span class="c1"># Transformation and Jacobian computation</span>
            <span class="c1">#============================================</span>

            <span class="c1"># Compute the transformed points and the Jacobian with respect to the parameters</span>
            <span class="n">transformed_points_itk</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">jacobian_dp</span> <span class="o">=</span> <span class="n">object_class</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">input_points</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># shape (Npoints, output_dim), None, (Npoints, output_dim, Nparams)</span>

            <span class="c1"># Check if the jacobian_dp is None$</span>
            <span class="k">if</span> <span class="n">jacobian_dp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Jacobian with respect to the parameters is not available. Please implement the _transform method to return the Jacobian with respect to the parameters.&quot;</span><span class="p">)</span>

            <span class="c1"># Check the convergence of the optimization</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">transformed_points_itk</span> <span class="o">-</span> <span class="n">output_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shape (Npoints,)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2">: |X_O - X_I| - Max difference: </span><span class="si">{</span><span class="n">numpy</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="si">}</span><span class="s2">, Mean difference: </span><span class="si">{</span><span class="n">numpy</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">diff</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimization converged in </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2"> iterations.&quot;</span><span class="p">)</span>
                <span class="k">break</span>
            
            <span class="c1">#===================================================</span>
            <span class="c1"># Create the residual vector and Jacobian matrix</span>
            <span class="c1">#===================================================</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#=====================================================&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;STARTING ITERATION </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> OF THE OPTIMIZATION PROCESS&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;#=====================================================&quot;</span><span class="p">)</span>

            <span class="c1"># Construct the residual vector R and the Jacobian J</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">output_points</span> <span class="o">-</span> <span class="n">transformed_points_itk</span>  <span class="c1"># shape (Npoints, output_dim)</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">jacobian_dp</span>  <span class="c1"># shape (Npoints, output_dim, Nparams)</span>

            <span class="c1"># Create masks to filter out invalid points</span>
            <span class="n">mask_R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Create a mask for finite values in R</span>
            <span class="n">mask_J</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># Create a mask for finite values in each row of J</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_R</span> <span class="o">&amp;</span> <span class="n">mask_J</span>  <span class="c1"># Combine the masks to filter out invalid points</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2"> valid points out of </span><span class="si">{</span><span class="n">Npoints</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="c1"># Apply the masks to R_flat and J_flat</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># shape (Nvalid_points, output_dim)</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>  <span class="c1"># shape (Nvalid_points, output_dim, Nparams)</span>

            <span class="c1"># Flatten the residual vector and Jacobian matrix</span>
            <span class="n">R_flat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># Flatten the residual vector to shape (Npoints * output_dim,)</span>
            <span class="n">J_flat</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Npoints</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Flatten the Jacobian to shape (Npoints * output_dim, Nparams)</span>

            <span class="c1"># Compute the delta using the normal equations: J^T J delta = J^T R</span>
            <span class="n">JTJ</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_flat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">J_flat</span><span class="p">)</span>  <span class="c1"># shape (Nparams, Nparams)</span>
            <span class="n">JTR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_flat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">R_flat</span><span class="p">)</span>  <span class="c1"># shape (Nparams,)</span>


            <span class="c1">#===================================================</span>
            <span class="c1"># Regularization and conditioning part</span>
            <span class="c1">#===================================================</span>

            <span class="c1"># Display the condition number of the Jacobian matrix without regularization</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: Condition number of JTJ before preconditionning and regularization: </span><span class="si">{</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">JTJ</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Add regularization if requested</span>
            <span class="k">if</span> <span class="n">reg_factor</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">JTJ</span> <span class="o">+=</span> <span class="n">reg_factor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: Condition number of JTJ after regularization: </span><span class="si">{</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">JTJ</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Apply preconditioning if requested</span>
            <span class="k">if</span> <span class="n">precond_jacobi</span><span class="p">:</span>
                <span class="c1"># Compute the diagonal of JTJ for Jacobi preconditioning</span>
                <span class="n">diag_JTJ</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">JTJ</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">diag_JTJ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Jacobi preconditioner cannot be applied because the diagonal of JTJ contains zeros.&quot;</span><span class="p">)</span>

                <span class="c1"># Apply the Jacobi preconditioner</span>
                <span class="n">JTJ</span> <span class="o">=</span> <span class="n">JTJ</span> <span class="o">/</span> <span class="n">diag_JTJ</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>  <span class="c1"># Normalize each row by the diagonal element</span>
                <span class="n">JTR</span> <span class="o">=</span> <span class="n">JTR</span> <span class="o">/</span> <span class="n">diag_JTJ</span>  <span class="c1"># Normalize the residual vector by the diagonal elements</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: Condition number of JTJ after Jacobi preconditioning: </span><span class="si">{</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">JTJ</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Display more information if _verbose is True.</span>
            <span class="k">if</span> <span class="n">_verbose_eigen</span><span class="p">:</span>
                <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">JTJ</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: Eigenvalues of JTJ:</span><span class="se">\n</span><span class="si">{</span><span class="n">eigvals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">ordered_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Sort eigenvalues in descending order</span>
                <span class="n">ordered_eigvals</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">[</span><span class="n">ordered_indices</span><span class="p">]</span>
                <span class="n">ordered_eigvecs</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">ordered_indices</span><span class="p">]</span>
                <span class="n">ordered_cond_number</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ordered_eigvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">ordered_eigvals</span><span class="p">)</span> 

                <span class="c1"># Display the eigenvalues</span>
                <span class="n">fig_eig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
                <span class="n">ax_eigval</span> <span class="o">=</span> <span class="n">fig_eig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ax_eigval</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">ordered_eigvals</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">)</span>
                <span class="n">ax_eigval</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ordered Eigenvalues of JTJ (Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="n">ax_eigval</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Index&quot;</span><span class="p">)</span>
                <span class="n">ax_eigval</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Eigenvalue (log scale)&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
                <span class="n">ax_eigval</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">labelcolor</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
                <span class="n">ax_eigval</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">ax_cond</span> <span class="o">=</span> <span class="n">ax_eigval</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
                <span class="n">ax_cond</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">ordered_cond_number</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
                <span class="n">ax_cond</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Condition Number |max(eig)/eig| (log scale)&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
                <span class="n">ax_cond</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">labelcolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
                <span class="n">ax_cond</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

                <span class="c1"># Display the eigenvectors</span>
                <span class="n">ax_eigvec</span> <span class="o">=</span> <span class="n">fig_eig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">ax_eigvec</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ordered_eigvecs</span><span class="p">),</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
                <span class="n">fig_eig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ax_eigvec</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax_eigvec</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Eigenvector Component&#39;</span><span class="p">)</span>
                <span class="n">ax_eigvec</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Eigenvectors of JTJ (Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="n">ax_eigvec</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Eigenvector Index&quot;</span><span class="p">)</span>
                <span class="n">ax_eigvec</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Eigenvector Component&quot;</span><span class="p">)</span>
                <span class="n">ax_eigvec</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="c1"># ===================================================</span>
            <span class="c1"># Condition number check</span>
            <span class="c1"># ===================================================</span>

            <span class="c1"># Condition number check</span>
            <span class="n">cond_number</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">JTJ</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: Condition number of JTJ: </span><span class="si">{</span><span class="n">cond_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">cond_number</span> <span class="o">&gt;</span> <span class="n">cond_cutoff</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Condition number </span><span class="si">{</span><span class="n">cond_number</span><span class="si">}</span><span class="s2"> exceeds cutoff </span><span class="si">{</span><span class="n">cond_cutoff</span><span class="si">}</span><span class="s2">. Optimization may be unstable. skipping iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> and returning NaN array.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nparams</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            
            <span class="c1"># ====================================================</span>
            <span class="c1"># Solve the linear system to find the delta</span>
            <span class="c1"># ====================================================</span>

            <span class="c1"># Solve the linear system to find the delta</span>
            <span class="n">delta_itk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">JTJ</span><span class="p">,</span> <span class="n">JTR</span><span class="p">)</span> <span class="c1"># shape (Nparams,)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: Delta parameters:</span><span class="se">\n</span><span class="si">{</span><span class="n">delta_itk</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="c1"># Update the parameters of the object class</span>
            <span class="n">object_class</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">object_class</span><span class="o">.</span><span class="n">parameters</span> <span class="o">+</span> <span class="n">delta_itk</span>  <span class="c1"># shape (Nparams,)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: Updated parameters:</span><span class="se">\n</span><span class="si">{</span><span class="n">object_class</span><span class="o">.</span><span class="n">parameters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">object_class</span><span class="o">.</span><span class="n">parameters</span>  <span class="c1"># shape (Nparams,)</span></div>

    

<div class="viewcode-block" id="Transform.optimize_input_points">
<a class="viewcode-back" href="../../../api_doc/transform.html#pydistort.core.Transform.optimize_input_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize_input_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">output_points</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">guess</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">transpose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_skip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the input points of the transformation using the given output points.</span>

<span class="sd">        Estimate the optimized input points of the transformation such that the transformed input points match the output points.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This method can only be used if the dimensions are the same, i.e. input_dim == dim.</span>

<span class="sd">        Lets consider a set of output points :math:`X_O` with shape (..., dim) and a set of input points :math:`X_I` with shape (..., input_dim).</span>
<span class="sd">        We search :math:`X_I = X_{I0} + \delta X_I` such that:</span>

<span class="sd">        .. math::</span>

<span class="sd">            X_O = \text{Transform}(X_I, \lambda) = T(X_I + \delta X_I, \lambda)</span>
<span class="sd">        </span>
<span class="sd">        We have:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla_{X} T (X_I, \lambda_0) \delta \lambda = X_O - T(X_I, \lambda_0)</span>

<span class="sd">        The corrections are computed using the following equations:</span>

<span class="sd">        .. math::</span>

<span class="sd">            J \delta X_I = R</span>

<span class="sd">        Where :math:`J = \nabla_{X} T (X_I, \lambda_0)` is the Jacobian matrix of the transformation with respect to the input points, and :math:`R = X_O - T(X_I, \lambda_0)` is the residual vector.</span>

<span class="sd">        :math:`X_{I0}` is the initial guess for the input points, if None, it use the output points as the initial guess.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The ``_skip`` parameter is used to skip the checks for the transformation parameters and assume the output points are given in the (Npoints, dim) float64 format.</span>
<span class="sd">            Please use this parameter with caution, as it may lead to unexpected results if the transformation parameters are not set correctly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_points : numpy.ndarray</span>
<span class="sd">            The output points to be matched. Shape (..., dim) (or (dim, ...) if `transpose` is True).</span>

<span class="sd">        guess : Optional[numpy.ndarray], optional</span>
<span class="sd">            The initial guess for the input points of the transformation with shape (..., dim). If None, the output points are used as the initial guess. Default is None.</span>

<span class="sd">        transpose : bool, optional</span>
<span class="sd">            If True, the output points are transposed to shape (dim, ...). Default is False.</span>

<span class="sd">        max_iter : int, optional</span>
<span class="sd">            The maximum number of iterations for the optimization. Default is 10.</span>

<span class="sd">        eps : float, optional</span>
<span class="sd">            The convergence threshold for the optimization. Default is 1e-8.</span>

<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If True, print the optimization progress and diagnostics. Default is False.</span>

<span class="sd">        _skip : bool, optional</span>
<span class="sd">            If True, skip the checks for the transformation parameters and assume the output points are given in the (Npoints, dim) float64 format.</span>
<span class="sd">            The guess must be given in the (Npoints, dim) float64 format.</span>
<span class="sd">            `transpose` is ignored if this parameter is set to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The optimized input points of the transformation with shape (..., dim).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the output points do not have the expected shape, or if the input and output dimensions do not match the transformation&#39;s input and output dimensions.</span>

<span class="sd">        TypeError</span>
<span class="sd">            If the output points or guess are not numpy arrays, or if the guess is not a numpy array.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input dimension (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="si">}</span><span class="s2">) must be equal to output dimension (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="si">}</span><span class="s2">) for this method to work.&quot;</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span>  <span class="c1"># Since input_dim == output_dim</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_skip</span><span class="p">:</span>
            <span class="c1"># Check the boolean flags</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transpose</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;transpose must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">transpose</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">max_iter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_iter must be an integer greater than 0, got </span><span class="si">{</span><span class="n">max_iter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="n">eps</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;eps must be a positive float, got </span><span class="si">{</span><span class="n">eps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;verbose must be a boolean, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Check if the transformation is set</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transformation parameters are not set. Please set the parameters before optimizing.&quot;</span><span class="p">)</span>

            <span class="c1"># Convert output points to float64</span>
            <span class="n">output_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">output_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># Check the guess</span>
            <span class="k">if</span> <span class="n">guess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use the output points as the initial guess</span>
                <span class="n">guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># Check the shape of the output points</span>
            <span class="k">if</span> <span class="n">output_points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output points must have at least 2 dimensions, got </span><span class="si">{</span><span class="n">output_points</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">guess</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Guess must have at least 2 dimensions, got </span><span class="si">{</span><span class="n">guess</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>
            
            <span class="c1"># Transpose the output points if requested</span>
            <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
                <span class="n">output_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">output_points</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># (dim, ...) -&gt; (..., dim)</span>
                <span class="n">guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># (dim, ...) -&gt; (..., dim)</span>

            <span class="c1"># Flatten the output points to 2D for processing</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">output_points</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># (..., dim)</span>
            <span class="n">output_points</span> <span class="o">=</span> <span class="n">output_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>  <span class="c1"># (..., dim) -&gt; (Npoints, dim)</span>
            <span class="n">guess</span> <span class="o">=</span> <span class="n">guess</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>  <span class="c1"># (..., dim) -&gt; (Npoints, dim)</span>
            
            <span class="c1"># Check the number of points</span>
            <span class="k">if</span> <span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">guess</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output points and guess must have the same number of points, got </span><span class="si">{</span><span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">guess</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> points respectively.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Output points and guess must have at least one point.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output points must have </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> dimensions, got </span><span class="si">{</span><span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">guess</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Guess must have </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> dimensions, got </span><span class="si">{</span><span class="n">guess</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span><span class="p">)</span>
            
        <span class="c1"># Initialize the guess for the input points</span>
        <span class="n">Npoints</span> <span class="o">=</span> <span class="n">output_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">delta_itk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="c1"># shape (Npoints, dim) (Delta for the next iteration)</span>
        <span class="n">Nopt</span> <span class="o">=</span> <span class="n">Npoints</span> <span class="c1"># Number of points in computation</span>

        <span class="c1"># Prepare the output array:</span>
        <span class="n">input_points</span> <span class="o">=</span> <span class="n">guess</span>

        <span class="c1"># Create the mask for the points in computation</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">output_points</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">input_points</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># shape (Npoints,)</span>

        <span class="c1"># Run the iterative algorithm</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="c1"># Compute the transformation of the input points and the Jacobian with respect to the input points</span>
            <span class="n">output_points_itk</span><span class="p">,</span> <span class="n">jacobian_dx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">input_points</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># shape (Nopt, dim), (Nopt, dim, dim), None</span>

            <span class="c1"># Check if the jacobian_dx is None</span>
            <span class="k">if</span> <span class="n">jacobian_dx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Jacobian with respect to the input points is not available. Please implement the _transform method to return the Jacobian with respect to the input points.&quot;</span><span class="p">)</span>
            
            <span class="c1"># Check the convergence of the optimization</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">output_points_itk</span> <span class="o">-</span> <span class="n">output_points</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shape (Nopt,)</span>
            <span class="n">eps_mask</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="c1"># shape (Nopt,)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">eps_mask</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimization converged in </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2"> iterations.&quot;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="n">Nopt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>  <span class="c1"># Update the number of points in computation</span>

            <span class="n">output_points_itk</span> <span class="o">=</span> <span class="n">output_points_itk</span><span class="p">[</span><span class="n">eps_mask</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># shape (NewNopt, dim)</span>
            <span class="n">jacobian_dx</span> <span class="o">=</span> <span class="n">jacobian_dx</span><span class="p">[</span><span class="n">eps_mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>  <span class="c1"># shape (NewNopt, dim, dim)</span>

            <span class="c1"># Construct the residual vector R and the Jacobian J</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">output_points</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">output_points_itk</span> <span class="c1"># shape (Nopt, dim)</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">jacobian_dx</span> <span class="c1"># shape (Nopt, dim, dim)</span>

            <span class="c1"># Solve the linear system to find the delta</span>
            <span class="n">delta_itk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nopt</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="c1"># shape (Nopt, dim)</span>

            <span class="c1"># Update the input points</span>
            <span class="n">input_points</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">input_points</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">delta_itk</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2"> valid points out of </span><span class="si">{</span><span class="n">Npoints</span><span class="si">}</span><span class="s2">. Max delta: </span><span class="si">{</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_itk</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Return the optimized input points</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_skip</span><span class="p">:</span>
            <span class="n">input_points</span> <span class="o">=</span> <span class="n">input_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="p">)</span>  <span class="c1"># (Npoints, dim) -&gt; (..., dim)</span>

            <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
                <span class="n">input_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">input_points</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># (..., dim) -&gt; (dim, ...)</span>

        <span class="k">return</span> <span class="n">input_points</span></div>
</div>


</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025-%Y, Artezaru.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>